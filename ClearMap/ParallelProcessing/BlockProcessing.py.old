# -*- coding: utf-8 -*-
"""
Process a image in parallel or sequentially

In this toolbox image processing is parallized via splitting a volumetric
image into several blocks in z-direction. As most of 
the image processig steps are non-local blocks are created with overlaps 
and the results rejoined accordingly to minimize boundary effects.
"""
#:copyright: Copyright 2015 by Christoph Kirst, The Rockefeller University, New York City
#:license: GNU, see LICENSE.txt for details.

import sys
import math
import numpy as np

from multiprocessing import Pool, cpu_count

import ClearMap.IO as io

from ClearMap.Utils.ParameterTools import writeParameter
from ClearMap.Utils.ProcessWriter import ProcessWriter;
from ClearMap.Utils.Timer import Timer;

class Block(io.Region.Region):
  """Block class to represent a block of image data to be processed in parallel"""
  def __init__(self, id = 0, source = None, region = None, validRegion = None,  x = None, y = None, z = None, dim = None):
    """Constructor"""
    self.id = id;
    super(io.Region.Region, self).__init__(source = source, region = region, x = x, y = y, z = z, dim =dim);
    if validRegion is None or validRegion is all:
      self.validRegion = region;
    else:
      self.validRegion = validRegion;
    #self.neighbours = neighbours;
  
  def reduce(self):
    """Returns the central region of the block not overlapping"""
    return None;
  
  def reducedSourceSlice(self):
    """Returns reduced slice in the source taking into account the overlaps"""
    if self.validRegion is None:
      return self.sourcSlice();
    else:
      return self.border.sourceSlice();
      
    
  def reducedData(self):
    """Returns the reduced block data taking into account the overlaps"""
    
    
    
  def __str__(self):
    par = {'Block'   : self.id, 
           'Slice'   : super(io.Region.Region, self).__str__(),
           'Overlap' : self.overlap,
           'Border'  : self.border,
           '#Blocks' : self.nBlocks,
           '#Neighbours' : len(self.neighbours)};
    return writeParameter(par);
    
  def __repr__(self):
    return self.__str__();
    
    
  
def wrapFunction(function, *args, **kwargs):
  """Wrap a function to fit the parallel processing format"""
  def f(data, block, out):
    return function(data, *args, **kwargs);
  return f;


def processBlock(block, function, verbose = False):
    """Helper to process block in parallel"""
    
    timer = Timer();
    pw = ProcessWriter(block.id);
    
    if verbose:
        pw.write("processing block %d / %d" % (block.id, block.nBlocks));
        if isinstance(block.source, basestring):
          pw.write("source        = %r" % block.source);
        pw.write("segmentation  = " + str(function));
        pw.write("slice         = %r" % block.slice()); 
    
    img = io.readData(block.source, block);
    
    if verbose:
        pw.write(timer.elapsedTime(head = 'Reading data of size ' + str(img.shape)));
    
    timer.reset();
    seg = function(img, block = Block, out = pw);

    if verbose:    
        pw.write(timer.elapsedTime(head = 'Processing substack of size ' + str(img.shape)));
    
    return seg;


def writeBlock(sink, data, block):
    """Write the non-redundant part of a block to disk
    
    The routine is used to write out images when porcessed in parallel.
    
    Arguments:
        sink (str or None): file name pattern as used by :mod:`~ClearMap.Io.FileList` 
                            or memory map as used in :mod:`~ClearMap.Io.MMP
        data (array): data of the block
        block (dict): sub-stack information, if None write entire image
    
    Returns:
       str or array: the file name pattern or image
    """
    
    dataSlice = block.validRegion.slice();
    sinkSlice = block.sourceSlice();
    return io.writeData(sink, data[dataSlice], region = sinkSlice);     



def calculateBlockSizesZ(size, processes = cpu_count(), blockSizeMax = 100, blockSizeMin = 30, blockOverlap = 15,  blockOptimization = True, blockOptimizationSize = all, verbose = True):
    """Calculates block sizes in z-direction and other info for parallel processing
    
    Arguments:
        processes (int): number of parallel processes
        blockSizeMax (int): maximal size of a sub-stack
        blockSizeMin (int): minial size of a sub-stack
        blockOverlap (int): minimal sub-stack overlap
        blockOptimization (bool): optimize chunck sizes to best fit number of processes
        blockOptimizationSize (bool or all): if True only decrease the block size when optimizing
        verbose (bool): print information on sub-stack generation
        
    Returns:
        tuple: number of blocks, z-ranges of each block, z-centers in overlap regions
    """
    
    pre = "BlockSize: ";
    
    #calcualte block sizes
    blocksize = blockSizeMax;
    nblocks = int(math.ceil((size - blocksize) / (1. * (blocksize - blockOverlap)) + 1)); 
    if nblocks <= 0:
        nblocks = 1;   
    blocksize = (size + (nblocks-1) * blockOverlap) / nblocks;
    
    if verbose:
        print pre + "Estimated block size " + str(blocksize) + " in " + str(nblocks) + " blocks!";
    
    if nblocks == 1:
        return 1, [(0, blocksize)], [0, blocksize]
        
    #optimize number of blocks wrt to number of processors
    if blockOptimization:
        npr = nblocks % processes;
        if npr != 0:
            if blockOptimizationSize is all:
                if npr < processes / 2.0:
                    blockOptimizationSize = True;
                else:
                    blockOptimizationSize = False;
                    
            if verbose:
                print pre + "Optimizing block size to fit number of processes!"
                
            if not blockOptimizationSize:
                #try to deccrease blocksize / increase block number to fit distribution on processors
                nblocks = nblocks - npr + processes;
                blocksize = (size + (nblocks-1) * blockOverlap) / nblocks;
                
                if verbose:
                    print pre + "Optimized block size decreased to " + str(blocksize) + " in " + str(nblocks) + " blocks!";
                    
            else:
                if nblocks != npr:
                    #try to decrease block number to fit  processors
                    nblocks = nblocks - npr;
                    blocksize = (size + (nblocks-1) * blockOverlap) / nblocks;
                                  
                    if verbose:
                        print pre + "Optimized block size increased to " + str(blocksize) + " in " + str(nblocks) + " blocks!";
                
                else:
                    if verbose:
                        print pre + "Optimized block size unchanged " + str(blocksize) + " in " + str(nblocks) + " blocks!";
        
        else:
            if verbose:
                print pre + "Optimized block size unchanged " + str(blocksize) + " in " + str(nblocks) + " blocks!";
    
    
    #increase overlap if blocks to small
    blockSizeMin = min(blockSizeMin, blockOverlap);
    if blocksize < blockSizeMin:
        if verbose: 
            print pre + "Warning: optimal block size " + str(blocksize) + " smaller than minimum block size " + str(blockSizeMin) + "!"; 
        blocksize = blockSizeMin;
        blockOverlap = math.ceil(blocksize - (size - blocksize) / (nblocks -1));
        
        if verbose:        
            print pre + "Warning: setting block overlap to " + str(blockOverlap) + "!";
           
    #calucalte actual block sizes
    blocksizerest = blocksize;
    blocksize = int(math.floor(blocksize));
    blocksizerest = blocksizerest - blocksize;
    
    zranges = [(0, blocksize)];
    zcenters = [0];
    n = 1;
    csr = blocksizerest;
    zhi = blocksize;
    
    while (n < nblocks):
        n += 1;
        
        zhiold = zhi;
        zlo = zhi - blockOverlap;
        zhi = zlo + blocksize;
        
        csr += blocksizerest;
        if csr >= 1:
            csr = csr - 1;
            zhi += 1;
        
        if n == nblocks:        
            zhi = size;
        
        zranges.append((int(zlo), int(zhi)));
        zcenters.append((zhiold - zlo) / 2. + zlo); 
        
    zcenters.append(size);
    
    if verbose:    
        print zranges
        print pre + "final blocks : " + str(zranges);
        print pre + "final centers: " + str(zcenters);
    
    return nblocks, zranges, zcenters;


def calculateBlocksZ(source, region = None, **args):
    """Calculates the block sizes along z-axis and other info for parallel processing and returns a list of blocks
    
    Arguments:
        source (str): image source
        processes (int): number of parallel processes
        blockSizeMax (int): maximal size of a sub-stack
        blockSizeMin (int): minial size of a sub-stack
        blockOverlap (int): minimal sub-stack overlap
        blockOptimization (bool): optimize chunck sizes to best fit number of processes
        blockOptimizationSize (bool or all): if True only decrease the block size when optimizing
        verbose (bool): print information on sub-stack generation
        
    Returns:
        list: list of blocks
    """    
    
    #determine z ranges
    fs = io.dataSize(source);
    zs = fs[2];
    zr = io.toDataRange(zs, r = z);
    nz = zr[1] - zr[0];
    
    #calculate optimal block sizes
    nblocks, zranges, zcenters = calculateblockSize(nz, **args);
    
    #adjust for the zrange
    zcenters = [c + zr[0] for c in zcenters];
    zranges = [(zc[0] + zr[0], zc[1] + zr[0]) for zc in zranges];
    
    #create substacks
    subStacks = [];
    indexlo = zr[0];
    
    for i in range(nblocks):
        
        indexhi = int(round(zcenters[i+1]));
        if indexhi > zr[1] or i == nblocks - 1:
            indexhi = zr[1];
        
        zs = zranges[i][1] - zranges[i][0];
        
        subStacks.append({"stackId" : i, "nStacks" : nblocks, 
                          "source" : source, "x" : x, "y" : y, "z" : zranges[i], 
                          "zCenters" : (zcenters[i], zcenters[i+1]),
                          "zCenterIndices" : (indexlo, indexhi),
                          "zSubStackCenterIndices" : (indexlo - zranges[i][0], zs - (zranges[i][1] - indexhi))});
        
        indexlo = indexhi; # + 1;
    
    return subStacks;


        
def noProcessing(img, **parameter):
    """Perform no image processing at all and return original image
    
    Used as the default functon in :func:`parallelProcessStack` and
    :func:`sequentiallyProcessStack`.
    
    Arguments:
        img (array): imag
        
    Returns:
        (array): the original image
    """

def parallelProcessStack(source, x = all, y = all, z = all, sink = None,
                         processes = 2, blockSizeMax = 100, blockSizeMin = 30, blockOverlap = 15,
                         blockOptimization = True, blockOptimizationSize = all, 
                         function = noProcessing, join = joinPoints, verbose = False, **parameter):
    """Parallel process a image stack
    
    Main routine that distributes image processing on paralllel processes.
       
    Arguments:
        source (str): image source
        x,y,z (tuple or all): range specifications
        sink (str or None): destination for the result
        processes (int): number of parallel processes
        blockSizeMax (int): maximal size of a sub-stack
        blockSizeMin (int): minial size of a sub-stack
        blockOverlap (int): minimal sub-stack overlap
        blockOptimization (bool): optimize chunck sizes to best fit number of processes
        blockOptimizationSize (bool or all): if True only decrease the block size when optimizing
        function (function): the main image processing script
        join (function): the fuction to join the results from the image processing script
        verbose (bool): print information on sub-stack generation
        
    Returns:
        str or array: results of the image processing
    """     
    
    subStacks = calculateSubStacks(source, x = x, y = y, z = z, 
                                   processes = processes, blockSizeMax = blockSizeMax, blockSizeMin = blockSizeMin, blockOverlap = blockOverlap,
                                   blockOptimization = blockOptimization, blockOptimizationSize = blockOptimizationSize, verbose = verbose);
                                   
    nSubStacks = len(subStacks);
    if verbose:
        print "Number of SubStacks: %d" % nSubStacks;
                                       
    #for i in range(nSubStacks):
    #    self.printSubStackInfo(subStacks[i]);
    
    argdata = [];
    for i in range(nSubStacks):
        argdata.append((function, parameter, subStacks[i], verbose));    
    #print argdata
    
    # process in parallel
    pool = Pool(processes = processes);    
    results = pool.map(_processSubStack, argdata);
    
    #print '=========== results';
    #print results;
        
    #join the results
    results = join(results, subStacks = subStacks, **parameter);
    
    #write / or return 
    return io.writePoints(sink, results);


def sequentiallyProcessStack(source, x = all, y = all, z = all, sink = None,
                             blockSizeMax = 100, blockSizeMin = 30, blockOverlap = 15,
                             function = noProcessing, join = joinPoints, verbose = False, **parameter):
    """Sequential image processing on a stack
    
    Main routine that sequentially processes a large image on sub-stacks.
       
    Arguments:
        source (str): image source
        x,y,z (tuple or all): range specifications
        sink (str or None): destination for the result
        processes (int): number of parallel processes
        blockSizeMax (int): maximal size of a sub-stack
        blockSizeMin (int): minial size of a sub-stack
        blockOverlap (int): minimal sub-stack overlap
        blockOptimization (bool): optimize chunck sizes to best fit number of processes
        blockOptimizationSize (bool or all): if True only decrease the block size when optimizing
        function (function): the main image processing script
        join (function): the fuction to join the results from the image processing script
        verbose (bool): print information on sub-stack generation
        
    Returns:
        str or array: results of the image processing
    """     
    #determine z ranges  
    
    subStacks = calculateSubStacks(source, x = x, y = y, z = z, 
                                   processes = 1, blockSizeMax = blockSizeMax, blockSizeMin = blockSizeMin, blockOverlap = blockOverlap,  
                                   blockOptimization = False, verbose = verbose);
    
    nSubStacks = len(subStacks);
    #print nSubStacks;    
    
    argdata = [];
    for i in range(nSubStacks):
        argdata.append((function, parameter, subStacks[i], verbose));    
    
    #run sequentially
    results = [];
    for i in range(nSubStacks):
        results.append(_processSubStack(argdata[i]));
    
    #join the results
    results = join(results, subStacks = subStacks, **parameter);
    
    #write / or return 
    return io.writePoints(sink, results);



